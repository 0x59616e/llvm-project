//===-- M68kInstructionSelector.cpp -----------------------------*- C++ -*-===//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// M68k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M68kInstrInfo.h"
#include "M68kRegisterBankInfo.h"
#include "M68kRegisterInfo.h"
#include "M68kSubtarget.h"
#include "M68kTargetMachine.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/Support/Debug.h"

#define DEBUG_TYPE "m68k-isel"

using namespace llvm;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "M68kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

namespace {

class M68kInstructionSelector : public InstructionSelector {
public:
  M68kInstructionSelector(const M68kTargetMachine &TM, const M68kSubtarget &STI,
                          const M68kRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  static const char *getName() { return DEBUG_TYPE; }

  // Address Register Indirect
  ComplexRendererFns selectARI(MachineOperand &Root) const;
  // Address Register Indirect with PostIncrement
  ComplexRendererFns selectARIPI(MachineOperand &Root) const;
  // Address Register Indirect with PreDecrement
  ComplexRendererFns selectARIPD(MachineOperand &Root) const;
  // Address Register Indirect with Displacement
  ComplexRendererFns selectARID(MachineOperand &Root) const;
  // Address Register Indirect with Index
  ComplexRendererFns selectARII(MachineOperand &Root) const;
  // Absolute Long Address Mode
  ComplexRendererFns selectAL(MachineOperand &Root) const;
  // Program Counter with Displacement
  ComplexRendererFns selectPCD(MachineOperand &Root) const;
  // Program Counter with Index
  ComplexRendererFns selectPCI(MachineOperand &Root) const;

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  bool constrainCopy(MachineInstr &I) const;
  bool constrainPHI(MachineInstr &I) const;
  unsigned changePredicateTo(CmpInst::Predicate Pred,
                             ArrayRef<unsigned> To) const;
  bool emitCompare(MachineInstr &I, MachineOperand &LHS, MachineOperand &RHS);
  bool emitCompareAndBranch(MachineInstr &ICmp, MachineInstr &Br);
  bool emitSelect(MachineInstr &I);

  const M68kTargetMachine &TM;
  const M68kInstrInfo &TII;
  const M68kRegisterInfo &TRI;
  const M68kRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "M68kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "M68kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "M68kGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

M68kInstructionSelector::M68kInstructionSelector(
    const M68kTargetMachine &TM, const M68kSubtarget &STI,
    const M68kRegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "M68kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "M68kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

InstructionSelector::ComplexRendererFns
M68kInstructionSelector::selectARI(MachineOperand &Root) const {
  return None;
}

InstructionSelector::ComplexRendererFns
M68kInstructionSelector::selectARIPI(MachineOperand &Root) const {
  return None;
}

InstructionSelector::ComplexRendererFns
M68kInstructionSelector::selectARIPD(MachineOperand &Root) const {
  return None;
}

InstructionSelector::ComplexRendererFns
M68kInstructionSelector::selectARID(MachineOperand &Root) const {
  LLVM_DEBUG(dbgs() << "GISel: Selecting ARID\n");

  MachineRegisterInfo &MRI = Root.getParent()->getMF()->getRegInfo();

  MachineInstr *RootDef = MRI.getVRegDef(Root.getReg());

  switch (RootDef->getOpcode()) {
  default:
    break;
  case TargetOpcode::G_PTR_ADD: {
    auto ValAndVReg = getIConstantVRegValWithLookThrough(
        RootDef->getOperand(2).getReg(), MRI);

    if (!ValAndVReg)
      break;

    int64_t Imm = ValAndVReg->Value.getSExtValue();
    Register Reg = RootDef->getOperand(1).getReg();

    return {{[=](MachineInstrBuilder &MIB) { MIB.addImm(Imm).addUse(Reg); }}};
  }
  case TargetOpcode::G_FRAME_INDEX:
    return {{[=](MachineInstrBuilder &MIB) {
      MIB.addImm(0).add(RootDef->getOperand(1));
    }}};
  }

  return None;
}

InstructionSelector::ComplexRendererFns
M68kInstructionSelector::selectARII(MachineOperand &Root) const {
  return None;
}

InstructionSelector::ComplexRendererFns
M68kInstructionSelector::selectAL(MachineOperand &Root) const {
  return None;
}

InstructionSelector::ComplexRendererFns
M68kInstructionSelector::selectPCD(MachineOperand &Root) const {
  return None;
}

InstructionSelector::ComplexRendererFns
M68kInstructionSelector::selectPCI(MachineOperand &Root) const {
  return None;
}

bool M68kInstructionSelector::constrainCopy(MachineInstr &I) const {
  MachineOperand &Dst = I.getOperand(0);
  MachineOperand &Src = I.getOperand(1);
  MachineRegisterInfo &MRI = I.getMF()->getRegInfo();

  if (Dst.getReg().isVirtual() && Src.getReg().isPhysical()) {
    auto &RegBankOrClass = MRI.getRegClassOrRegBank(Dst.getReg());
    if (RegBankOrClass.is<const TargetRegisterClass *>())
      return true;

    LLT Ty = MRI.getType(Dst.getReg());
    const TargetRegisterClass *TRI = nullptr;
    if (Ty.getSizeInBits() <= 8) {
      TRI = &M68k::DR8RegClass;
    } else if (Ty.getSizeInBits() == 16) {
      TRI = &M68k::XR16RegClass;
    } else {
      TRI = &M68k::XR32RegClass;
    }

    assert(TRI && "No register class ??");
    return RBI.constrainGenericRegister(Dst.getReg(), *TRI, MRI);
  }

  return true;
}

bool M68kInstructionSelector::constrainPHI(MachineInstr &I) const {
  MachineRegisterInfo &MRI = I.getMF()->getRegInfo();
  Register DefReg = I.getOperand(0).getReg();
  LLT DefTy = MRI.getType(DefReg);

  const RegClassOrRegBank &RB = MRI.getRegClassOrRegBank(DefReg);

  if (RB.is<const TargetRegisterClass *>())
    return true;

  const TargetRegisterClass *TRI = nullptr;
  if (DefTy.getSizeInBits() <= 8) {
    TRI = &M68k::DR8RegClass;
  } else if (DefTy.getSizeInBits() == 16) {
    TRI = &M68k::XR16RegClass;
  } else {
    TRI = &M68k::XR32RegClass;
  }
  assert(TRI && "No register class ??");

  I.setDesc(TII.get(TargetOpcode::PHI));

  return RBI.constrainGenericRegister(DefReg, *TRI, MRI);
}

unsigned
M68kInstructionSelector::changePredicateTo(CmpInst::Predicate Pred,
                                           ArrayRef<unsigned> To) const {
  assert(To.size() ==
         CmpInst::LAST_ICMP_PREDICATE - CmpInst::FIRST_ICMP_PREDICATE + 1);
  assert(Pred >= CmpInst::FIRST_ICMP_PREDICATE &&
         Pred <= CmpInst::LAST_ICMP_PREDICATE);

  return To[Pred - CmpInst::FIRST_ICMP_PREDICATE];
}

bool M68kInstructionSelector::emitCompare(MachineInstr &I, MachineOperand &LHS, MachineOperand &RHS) {
  // TODO: complex pattern matching
  MachineInstr *NewMI = BuildMI(*I.getParent(), &I, I.getDebugLoc(), TII.get(M68k::CMP32dr))
      .add(RHS)
      .add(LHS);
  constrainSelectedInstRegOperands(*NewMI, TII, TRI, RBI);
  return true;
}

bool M68kInstructionSelector::emitCompareAndBranch(MachineInstr &ICmp,
                                                   MachineInstr &Br) {
  emitCompare(Br, ICmp.getOperand(2), ICmp.getOperand(3));
  auto Pred =
      static_cast<CmpInst::Predicate>(ICmp.getOperand(1).getPredicate());
  unsigned Opc = changePredicateTo(
      Pred, {M68k::Beq8, M68k::Bne8, M68k::Bhi8, M68k::Bcc8, M68k::Bcs8,
             M68k::Bls8, M68k::Bgt8, M68k::Bge8, M68k::Blt8, M68k::Ble8});

  MachineInstr *NewMI = BuildMI(*Br.getParent(), &Br, Br.getDebugLoc(), TII.get(Opc))
      .add(Br.getOperand(1));

  Br.eraseFromParent();
  constrainSelectedInstRegOperands(*NewMI, TII, TRI, RBI);
  return true;
}

bool M68kInstructionSelector::emitSelect(MachineInstr &I) {
  MachineRegisterInfo &MRI = I.getMF()->getRegInfo();
  MachineInstr *ICmp = MRI.getVRegDef(I.getOperand(1).getReg());

  emitCompare(I, ICmp->getOperand(2), ICmp->getOperand(3));
  auto Pred =
      static_cast<CmpInst::Predicate>(ICmp->getOperand(1).getPredicate());
  unsigned Imm = changePredicateTo(
      Pred, {M68k::COND_EQ, M68k::COND_NE, M68k::COND_HI, M68k::COND_CC,
             M68k::COND_CS, M68k::COND_LS, M68k::COND_GT, M68k::COND_GE,
             M68k::COND_LT, M68k::COND_LE});
  MachineInstr *NewMI = BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(M68k::CMOV32r))
      .add(I.getOperand(0))
      .add(I.getOperand(3))
      .add(I.getOperand(2))
      .addImm(Imm);

  I.eraseFromParent();
  constrainSelectedInstRegOperands(*NewMI, TII, TRI, RBI);
  return true;
}

bool M68kInstructionSelector::select(MachineInstr &I) {
  if (I.isCopy())
    return constrainCopy(I);

  if (I.isPHI())
    return constrainPHI(I);

  // Certain non-generic instructions also need some special handling.
  if (!isPreISelGenericOpcode(I.getOpcode()))
    return true;

  MachineRegisterInfo &MRI = I.getMF()->getRegInfo();
  switch (I.getOpcode()) {
  default:
    break;
  case TargetOpcode::G_SELECT:
    return emitSelect(I);
  case TargetOpcode::G_GLOBAL_VALUE: {
    const GlobalValue *GV = I.getOperand(1).getGlobal();
    // TODO: Support thread local storage
    if (GV->isThreadLocal())
      return false;

    const M68kSubtarget &STI = I.getMF()->getSubtarget<M68kSubtarget>();
    unsigned Flags = STI.classifyGlobalReference(GV);

    // TODO: Support other addressing mode
    if (Flags == M68kII::MO_PC_RELATIVE_ADDRESS) {
      I.setDesc(TII.get(M68k::LEA32q));
      MachineInstrBuilder MIB(*I.getMF(), I);
      I.RemoveOperand(1);
      MIB.addGlobalAddress(GV, 0, Flags);
      constrainSelectedInstRegOperands(I, TII, TRI, RBI);
      return true;
    }
    return false;
  }
  case TargetOpcode::G_BRCOND: {
    MachineInstr *ICmp = MRI.getVRegDef(I.getOperand(0).getReg());
    if (ICmp->getOpcode() != TargetOpcode::G_ICMP)
      return false;
    return emitCompareAndBranch(*ICmp, I);
  }

  case TargetOpcode::G_BR: {
    I.setDesc(TII.get(M68k::BRA8));
    return true;
  }

  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE: {
    // GlobalISel does not support p0 very well.
    // For example, we need to change:
    // ```
    // %0:_(p0) = G_LOAD ...
    // ```
    // into this:
    // ```
    // %0_(s32) = G_LOAD
    // ```
    Register Reg = I.getOperand(0).getReg();
    LLT Ty = MRI.getType(Reg);
    if (Ty.isPointer()) {
      MRI.setType(Reg, LLT::scalar(32));
    }
    break;
  }
  }

  if (selectImpl(I, *CoverageInfo))
    return true;

  return false;
}

namespace llvm {
InstructionSelector *
createM68kInstructionSelector(const M68kTargetMachine &TM,
                              const M68kSubtarget &Subtarget,
                              const M68kRegisterBankInfo &RBI) {
  return new M68kInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
